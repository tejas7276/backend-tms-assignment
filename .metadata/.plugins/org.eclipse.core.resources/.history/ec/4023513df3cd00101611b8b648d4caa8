package com.tms.backend.service;

import com.tms.backend.entity.*;
import com.tms.backend.entity.enums.*;
import com.tms.backend.exception.*;
import com.tms.backend.repository.*;

import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.UUID;

@Service
public class BidService {

    private final BidRepository bidRepository;
    private final LoadRepository loadRepository;
    private final TransporterRepository transporterRepository;

    public BidService(BidRepository bidRepository, LoadRepository loadRepository,
                      TransporterRepository transporterRepository) {
        this.bidRepository = bidRepository;
        this.loadRepository = loadRepository;
        this.transporterRepository = transporterRepository;
    }

    @Transactional
    public Bid createBid(UUID loadId, UUID transporterId, double rate, int trucksOffered) {

        Load load = loadRepository.findById(loadId)
                .orElseThrow(() -> new ResourceNotFoundException("Load not found"));

        if (load.getStatus() == LoadStatus.CANCELLED || load.getStatus() == LoadStatus.BOOKED) {
            throw new InvalidStatusTransitionException("Cannot bid on CANCELLED or BOOKED load");
        }

        Transporter transporter = transporterRepository.findById(transporterId)
                .orElseThrow(() -> new ResourceNotFoundException("Transporter not found"));

        AvailableTruck capacity = transporter.getAvailableTrucks().stream()
                .filter(t -> t.getTruckType().equalsIgnoreCase(load.getTruckType()))
                .findFirst()
                .orElseThrow(() -> new InsufficientCapacityException("No trucks of required type"));

        if (trucksOffered > capacity.getCount()) {
            throw new InsufficientCapacityException("Offered trucks exceed available capacity");
        }

        if (load.getStatus() == LoadStatus.POSTED) {
            load.setStatus(LoadStatus.OPEN_FOR_BIDS);
            loadRepository.save(load);
        }

        Bid bid = new Bid();
        bid.setLoad(load);
        bid.setTransporter(transporter);
        bid.setProposedRate(rate);
        bid.setTrucksOffered(trucksOffered);
        bid.setStatus(BidStatus.PENDING);

        return bidRepository.save(bid);
    }

    @Transactional
    public Bid rejectBid(UUID bidId) {
        Bid bid = bidRepository.findById(bidId)
                .orElseThrow(() -> new ResourceNotFoundException("Bid not found"));
        bid.setStatus(BidStatus.REJECTED);
        return bidRepository.save(bid);
    }


    public List<Bid> searchBids(UUID loadId, UUID transporterId, BidStatus status) {

        if (loadId != null && transporterId != null && status != null) {
            return bidRepository.findByLoad_LoadIdAndTransporter_TransporterId(loadId, transporterId)
                    .stream()
                    .filter(b -> b.getStatus() == status)
                    .toList();
        } else if (loadId != null && transporterId != null) {
            return bidRepository.findByLoad_LoadIdAndTransporter_TransporterId(loadId, transporterId);
        } else if (loadId != null && status != null) {
            return bidRepository.findByLoad_LoadIdAndStatus(loadId, status);
        } else if (transporterId != null && status != null) {
            return bidRepository.findByTransporter_TransporterIdAndStatus(transporterId, status);
        } else if (loadId != null) {
            return bidRepository.findByLoad_LoadId(loadId);
        } else if (transporterId != null) {
            return bidRepository.findByTransporter_TransporterId(transporterId);
        } else if (status != null) {
            return bidRepository.findByStatus(status);
        }

        return bidRepository.findAll();
    }
}
